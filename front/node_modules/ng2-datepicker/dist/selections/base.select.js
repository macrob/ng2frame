import { EventEmitter } from '@angular/core';
import * as moment from 'moment';
import { DateState } from '../models';
import { extendDirConfig, selectProvider } from '../config_helpers';
export var BaseSelect = (function () {
    function BaseSelect() {
        this._value = this.EMPTY_VALUE;
        /*@Output()*/
        this.onDateChange = new EventEmitter();
        this.onStateChange = function () { };
        /* we're kinda doing our own change detection because some inputs
         * may be changed directly by template and not through property binding.
         * Such change are not covered by Angular change detection.
         *
         * We just want to know if something has changed not what has changed so
         * a boolean flag is enough
         */
        this.hasStateChanged = false;
    }
    /**
     * Extend the base configuration needed by @Directive
     * @param {Directive} config           subclass configuration
     * @param {Function}  directiveClasses subclass
     * @param {any[]}     ...a             useless just to please compiler if subclass wants to add parameter
     */
    //TODO the ...a trick works to keep compiler quiet but this will be transpiled into unseless code
    BaseSelect.extendConfig = function (config, directiveClasses) {
        var a = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            a[_i - 2] = arguments[_i];
        }
        return extendDirConfig({
            //we could auto-generate it using gulp or something
            inputs: ['minDate', 'maxDate'],
            outputs: ['onDateChange'],
            providers: [selectProvider(directiveClasses)],
        }, config);
    };
    Object.defineProperty(BaseSelect.prototype, "EMPTY_VALUE", {
        get: function () { },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseSelect.prototype, "value", {
        get: function () {
            return this._value;
        },
        /**
         * Set the value without any check (except null) and emit an onDateChange event
         * @param {T} value
         */
        set: function (value) {
            if (value !== this._value) {
                this.onDateChange.emit(this._value = value || this.EMPTY_VALUE);
                this.hasStateChanged = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseSelect.prototype, "minDate", {
        /*@Input()*/
        get: function () {
            return this._minDate;
        },
        set: function (date) {
            this._minDate = date;
            this.hasStateChanged = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseSelect.prototype, "maxDate", {
        /*@Input()*/
        get: function () {
            return this._maxDate;
        },
        set: function (date) {
            this._maxDate = date;
            this.hasStateChanged = true;
        },
        enumerable: true,
        configurable: true
    });
    BaseSelect.prototype.registerOnStateChange = function (fn) {
        this.onStateChange = fn;
    };
    BaseSelect.prototype.ngDoCheck = function () {
        if (this.hasStateChanged)
            this.onStateChange();
        this.hasStateChanged = false;
    };
    /**
     * Return a date corresponding to the day of the input date.
     * We don't want to introduce time in our dates.
     * @param  {moment.Moment} date A date that may have time in it
     * @return {moment.Moment}      A date corresponding to a day with all time unit to 0.
     */
    BaseSelect.prototype.getDay = function (date) {
        return date ? moment([date.year, date.month, date.date]) : null;
    };
    /** Returns true when date is between minDate and maxDate */
    BaseSelect.prototype.isDateValid = function (date) {
        return date &&
            (!this.minDate || date.isSameOrAfter(this.minDate)) &&
            (!this.maxDate || date.isSameOrBefore(this.maxDate));
    };
    /**
     * return true if date is selectable meaning :
     *  - not null
     *  - valid
     *  - not already selected
     * Primarly meant to be used by selectDate() of subclass
     * @param  {moment.Moment} date [description]
     * @return {boolean}            [description]
     */
    BaseSelect.prototype.isDateSelectable = function (date) {
        return date && this.isDateValid(date) && !this.isDateSelected(date);
    };
    BaseSelect.prototype.getDateState = function (date) {
        if (!date)
            return DateState.disabled;
        if (this.isDateSelected(date))
            return DateState.selected;
        if (this.isDateInSelectRange(date))
            return DateState.inRange;
        if (this.isDateValid(date))
            return DateState.enabled;
    };
    return BaseSelect;
}());
//helper
export function isSameDay(date1, date2) {
    if (date1 && date2)
        return date1.isSame(date2, 'd');
    return false;
}

//# sourceMappingURL=base.select.js.map
