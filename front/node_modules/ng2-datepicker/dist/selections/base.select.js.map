{"version":3,"sources":["src/selections/base.select.ts"],"names":[],"mappings":"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","file":"base.select.js","sourcesContent":["import { Directive, Input, Output, EventEmitter, DoCheck, ChangeDetectionStrategy } from '@angular/core';\n\nimport * as moment from 'moment';\n\nimport { DateState } from '../models';\nimport { extendDirConfig, selectProvider } from '../config_helpers';\n\nexport abstract class BaseSelect<T> implements DoCheck {\n\n  /**\n   * Extend the base configuration needed by @Directive\n   * @param {Directive} config           subclass configuration\n   * @param {Function}  directiveClasses subclass\n   * @param {any[]}     ...a             useless just to please compiler if subclass wants to add parameter\n   */\n  //TODO the ...a trick works to keep compiler quiet but this will be transpiled into unseless code\n  static extendConfig(config: Directive, directiveClasses: Function, ...a: any[]) {\n    return extendDirConfig({\n      //we could auto-generate it using gulp or something\n      inputs: ['minDate', 'maxDate'],\n      outputs: ['onDateChange'],\n      providers: [selectProvider(directiveClasses)],\n    }, config);\n  }\n\n  protected abstract get EMPTY_VALUE(): T\n\n  private _value = this.EMPTY_VALUE;\n\n  get value(): T {\n    return this._value;\n  }\n\n  /**\n   * Set the value without any check (except null) and emit an onDateChange event\n   * @param {T} value\n   */\n  set value(value: T) {\n    if (value !== this._value) {\n      this.onDateChange.emit( this._value = value || this.EMPTY_VALUE );\n      this.hasStateChanged = true;\n    }\n  }\n\n  private _minDate: moment.Moment;\n\n  /*@Input()*/\n  get minDate(): moment.Moment {\n    return this._minDate;\n  }\n  set minDate(date: moment.Moment) {\n    this._minDate = date;\n    this.hasStateChanged = true;\n  }\n\n  private _maxDate: moment.Moment;\n\n  /*@Input()*/\n  get maxDate(): moment.Moment {\n    return this._maxDate;\n  }\n  set maxDate(date: moment.Moment) {\n    this._maxDate = date;\n    this.hasStateChanged = true;\n  }\n\n  /*@Output()*/\n  onDateChange = new EventEmitter<T>();\n\n  private onStateChange: () => void = () => {};\n\n  registerOnStateChange(fn: () => void) {\n    this.onStateChange = fn;\n  }\n\n  /* we're kinda doing our own change detection because some inputs\n   * may be changed directly by template and not through property binding.\n   * Such change are not covered by Angular change detection.\n   *\n   * We just want to know if something has changed not what has changed so\n   * a boolean flag is enough\n   */\n  public hasStateChanged = false;\n\n  ngDoCheck() {\n    if (this.hasStateChanged)\n      this.onStateChange();\n\n    this.hasStateChanged = false;\n  }\n\n  /**\n   * Set value with guards for min/max and limit(multi)\n   * @param {T}\n   * @return {moment.Moment}\n   */\n  abstract setValue(value: T): void\n\n  /**\n   * Return a date corresponding to the day of the input date.\n   * We don't want to introduce time in our dates.\n   * @param  {moment.Moment} date A date that may have time in it\n   * @return {moment.Moment}      A date corresponding to a day with all time unit to 0.\n   */\n  protected getDay(date: moment.Moment): moment.Moment {\n    return date ? moment([ date.year, date.month, date.date]) : null;\n  }\n\n  /**\n   * Should probably always start as :\n   *\n   * if( !this.isDateSelectable(date) )\n   *   return false\n   *\n   * @param  {moment.Moment} date [description]\n   * @return {boolean}            [description]\n   */\n  abstract selectDate(date: moment.Moment): boolean\n  abstract unselectDate(date: moment.Moment): boolean\n  abstract isDateSelected(date: moment.Moment): boolean\n  abstract isDateInSelectRange(date: moment.Moment): boolean\n\n  /** Returns true when date is between minDate and maxDate */\n  isDateValid(date: moment.Moment): boolean {\n    return date &&\n      (!this.minDate || date.isSameOrAfter(this.minDate)) &&\n      (!this.maxDate || date.isSameOrBefore(this.maxDate));\n  }\n\n  /**\n   * return true if date is selectable meaning :\n   *  - not null\n   *  - valid\n   *  - not already selected\n   * Primarly meant to be used by selectDate() of subclass\n   * @param  {moment.Moment} date [description]\n   * @return {boolean}            [description]\n   */\n  protected isDateSelectable(date: moment.Moment): boolean {\n    return date && this.isDateValid(date) && !this.isDateSelected(date);\n  }\n\n  getDateState(date: moment.Moment): DateState {\n    if(!date)\n      return DateState.disabled;\n\n    if(this.isDateSelected(date))\n      return DateState.selected;\n\n    if(this.isDateInSelectRange(date))\n      return DateState.inRange;\n\n    if(this.isDateValid(date))\n      return DateState.enabled;\n  }\n}\n\n//helper\nexport function isSameDay(date1: moment.Moment, date2: moment.Moment) {\n  if (date1 && date2)\n    return date1.isSame(date2, 'd');\n\n  return false;\n}\n"]}